name: Cody â€” Apply Work Order (v2)

on:
  # Let you run it directly from Actions with fields (no issue required)
  workflow_dispatch:
    inputs:
      branch_name: { description: "Branch name", required: true }
      file_ops: { description: "CREATE/APPEND blocks", required: true }
      commit_messages: { description: "Commit messages (one per line)", required: false }
      pr_title_body: { description: "PR title (first line) + body", required: true }

  # Still support the label flow from an Issue Form
  issues:
    types: [labeled]

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  apply:
    # Run when: (A) manual dispatch, or (B) an issue gets the cody-apply label
    if: >
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'issues' &&
       github.event.action == 'labeled' &&
       github.event.label.name == 'cody-apply')
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - id: parse
        uses: actions/github-script@v7
        with:
          script: |
            const isDispatch = context.eventName === 'workflow_dispatch';
            let branchName, fileOpsRaw, commitsRaw, prTitleBody;

            function sectionAny(body, names) {
              for (const title of names) {
                const re = new RegExp(
                  `(?:\\*\\*${title}\\*\\*|###\\s+${title})[\\s\\r\\n]+([\\s\\S]*?)(?=\\n(?:\\*\\*|###\\s+)|$)`,
                  'i'
                );
                const m = body.match(re);
                if (m) return m[1].trim();
              }
              return "";
            }

            if (isDispatch) {
              const get = (k) => (core.getInput(k) || "").trim();
              branchName   = get('branch_name');
              fileOpsRaw   = get('file_ops');
              commitsRaw   = get('commit_messages');
              prTitleBody  = get('pr_title_body');
            } else {
              const body = (context.payload.issue && context.payload.issue.body) || "";
              branchName  = sectionAny(body, ["Branch name","Branch Name"]);
              fileOpsRaw  = sectionAny(body, ["File operations","File Operations"]);
              commitsRaw  = sectionAny(body, ["Commit messages","Commit Messages"]);
              prTitleBody = sectionAny(body, ["PR title and body","PR Title and Body","PR title","PR Title"]);
            }

            if (!branchName) throw new Error("Branch name not found in inputs or issue body.");
            if (!fileOpsRaw) throw new Error("File operations block not found.");
            if (!prTitleBody) throw new Error("PR title/body not found.");

            const fs = require('fs'); const path = require('path');

            // Parse CREATE/APPEND sections
            const lines = fileOpsRaw.split(/\r?\n/);
            let i = 0, ops = [];
            while (i < lines.length) {
              const line = (lines[i] || "").trim();
              if (!line) { i++; continue; }
              const m = line.match(/^(CREATE|APPEND)\s+(.+)$/i);
              if (!m) { i++; continue; }
              const op = m[1].toUpperCase(), target = m[2].trim();
              i++;
              if ((lines[i] || "").trim() !== "<<<BEGIN") throw new Error(`Expected <<<BEGIN after ${op} ${target}`);
              i++;
              const buf = [];
              while (i < lines.length && (lines[i] || "").trim() !== "<<<END") { buf.push(lines[i]); i++; }
              if (i >= lines.length) throw new Error(`Missing <<<END for ${target}`);
              const content = buf.join("\n"); i++;
              ops.push({ op, target, content });
            }

            for (const {op, target, content} of ops) {
              const full = path.join(process.cwd(), target);
              fs.mkdirSync(path.dirname(full), { recursive: true });
              if (op === "CREATE") fs.writeFileSync(full, content, "utf8");
              else {
                let prev = ""; try { prev = fs.readFileSync(full, "utf8"); } catch {}
                fs.writeFileSync(full, prev + (prev ? "\n" : "") + content, "utf8");
              }
              core.info(`${op} ${target}`);
            }

            const commitMessages = (commitsRaw || "").split(/\r?\n/).map(s => s.trim()).filter(Boolean);
            const idx = prTitleBody.indexOf("\n");
            const prTitle = idx === -1 ? prTitleBody.trim() : prTitleBody.slice(0, idx).trim();
            const prBody  = idx === -1 ? "" : prTitleBody.slice(idx+1).trim();

            core.setOutput("branch", branchName);
            core.setOutput("commitMessage", commitMessages[0] || "chore(cody): apply work order files");
            core.setOutput("prTitle", prTitle);
            core.setOutput("prBody", prBody);

      - name: Commit & push
        run: |
          set -e
          BRANCH="${{ steps.parse.outputs.branch }}"
          git config user.name "cody-bot"
          git config user.email "cody-bot@users.noreply.github.com"
          git fetch origin || true
          git checkout -B "$BRANCH"
          git add -A
          if git diff --cached --quiet; then
            echo "No changes to commit."
          else
            git commit -m "${{ steps.parse.outputs.commitMessage }}"
          fi
          git push -u origin "$BRANCH" --force-with-lease

      - name: Open/Update PR
        uses: actions/github-script@v7
        with:
          script: |
            const head = "${{ steps.parse.outputs.branch }}";
            const base = "main";
            const title = "${{ steps.parse.outputs.prTitle }}";
            const body  = `${{ steps.parse.outputs.prBody }}`;
            const { data: prs } = await github.rest.pulls.list({
              owner: context.repo.owner, repo: context.repo.repo,
              head: `${context.repo.owner}:${head}`, state: "open"
            });
            if (prs.length) {
              await github.rest.pulls.update({
                owner: context.repo.owner, repo: context.repo.repo,
                pull_number: prs[0].number, title, body
              });
            } else {
              await github.rest.pulls.create({
                owner: context.repo.owner, repo: context.repo.repo,
                title, body, head, base
              });
            }
